#+TITLE: Emacs configuration
#+AUTHOR: Jonathan Neidel
#+EMAIL: emacs@jneidel.com

- https://emacsdocs.org/docs/elisp/File-Name-Expansion -> substitute-in-file-name
- http://xahlee.info/emacs/emacs/elisp_call_shell_command.html -> shell-command,
shell-command-to-string, async-shell-command
- format = printf

* Why Emacs?
Vim and zsh were my first introductions to free software and got me into the
world of GNU/Linux.
I greatly modifyed both to make them work the way I want.

My first linux distro was [[https://manjaro.org/][Manjaro]].
It was great, but over time I ran it it's limitations.
It wasn't so much the case I was lacking features, but that I lacked the freedom
to have things work as I wanted them to.
There were some minor, but persistant anoyances that I could not further debug
because of how much the system was abstracting away from me.
So I moved to what Manjaro is based on: [[https://archlinux.org/][Arch]].
Devoured the [[https://wiki.archlinux.org/title/Main_page][wiki]] and built an [[https://github.com/jneidel/dotfiles][elaborate setup]] for myself.

With time I felt the same way about vim as Manjaro.
I had all the features I wanted, a great IDE.
But, again (1) I lacked the fredom to have things work as I want them to and (2)
I was not able to debug some problems because of how much the system was
abstracting from me.
With this in mind I came across [[https://www.youtube.com/watch?v=JWD1Fpdd4Pc][a talk]] that convinced me that Emacs was were I
should head.

Emacs promised the freedom to tinker with every aspect of an understandable system.
These advantages over vim are because of it's design:
#+begin_quote
[…] an editor built up around the idea of LISP as a singular machine.
Every part of Emacs can be inspected, evaluated or modified because the editor
is approximately 95 percent elisp and 5 percent C code.

[…]

What makes LISP such a fantastic language is that source code and data
structures are intrinsically one and the same: the LISP source code you read as
a human is almost identical to how the code is manipulated as a data structure
by LISP — the distinction between the questions “What is data?” and “What is
code?” are nil.

[…]

When you write elisp you are not just writing snippets of code run in a sandbox,
isolated from everything — you are altering a living system; an operating system
running on an operating system.
Every variable you alter and every function you call is carried out by the very
same interpreter you use when you edit text.

Emacs is a hacker’s dream because it is one giant, mutable state. […]
You can re-define live functions; change variables left and right; and you can
query the system for its state at any time — state that changes with every key
stroke as Emacs responds to events from your keyboard to your network stack.
Emacs is self-documenting because it is the document.
There are no other editors that can do that.
No editor comes close.

– [[https://www.masteringemacs.org/book][Mastering Emacs]]
#+end_quote

After I started migrating my workflows to Emacs I realized that I will move
everything into Emacs.
The advantages are that overwhelming to me.

** Keyboard driven workflows
Vim has the downside of being all terminal (not pratical to run the gui
version), so no different font sizes, proper inline images, etc.

GUI editors (VS Code) are not an option, because they don't allow for completely
keyboard driven workflows. (Vim binding in VS code are terrible, switching to
terminal, tabs, etc., it just gets in your way.)

** Vim extensions
Configuring complex neovim plugins is just not fun.
Coc is super incosistent and brittle.

* Theme
https://www.jneidel.com/misc/colors/
#+begin_src emacs-lisp :tangle "init.el" :results silent
(load-theme 'an-old-hope t)

;; Don't prompt to confirm theme safety
(setq custom-safe-themes t)

;; Toggle between light and dark
(defun light-mode()
  "Activate the light color theme."
  (interactive)
  (use-package modus-themes
    :config
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme 'modus-operandi-tinted)))

(defun dark-mode()
  "Activate the dark color theme."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'an-old-hope))
#+end_src

Choose from the installed themes in `M-x customize-themes`.
[[https://www.greghendershott.com/2017/02/emacs-themes.html#][Setup for easy switching.]]

** Packaging
Prevent package.el from loading packages prior to init.el.
#+begin_src emacs-lisp :tangle "early-init.el" :results silent
(setq package-enable-at-startup nil)
#+end_src

https://protesilaos.com/emacs/dotemacs#h:424340cc-f3d7-4083-93c9-d852d40dfd40
https://protesilaos.com/codelog/2022-05-13-emacs-elpa-devel/
#+begin_src emacs-lisp :tangle "init.el" :results silent
(package-initialize)
;; (setq package-enable-at-startup t)
(setq package-install-upgrade-built-in t)

(eval-and-compile
  (require 'use-package-ensure)
  (setq use-package-always-ensure t))
;; default use-package only lazy load package if it exists, this also downloads a package if it is not installed

;; Make native compilation silent and prune its cache.
(when (native-comp-available-p)
  (setq native-comp-async-report-warnings-errors 'silent)
  (setq native-compile-prune-cache t))

(setq package-archives
      '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
        ("gnu-elpa-devel" . "https://elpa.gnu.org/devel/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa" . "https://melpa.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ))
(setq package-archive-priorities
      '(("gnu-elpa" . 3)
        ("melpa" . 2)
        ("nongnu" . 1)))

;; refresh packages in the background upon startup
;;(unless package-archive-contents
;;  (package-refresh-contents t))

;; use-package
;; (unless (package-installed-p 'use-package)
;;   (package-refresh-contents)
;;   (package-install 'use-package))

;; Install into separate package dirs for each Emacs version, to prevent bytecode incompatibility
;; (setq package-user-dir
;;       (expand-file-name (format "packages-%s.%s" emacs-major-version emacs-minor-version)
;;                         "~/.local/share/emacs"))

;; (setq package-enable-at-startup nil)
;; (package-initialize)

;; packages not available from repositories are in lib
;; (add-to-list 'load-path (expand-file-name "lib" user-emacs-directory))
#+end_src

[[https://protesilaos.com/codelog/2024-07-23-emacs-use-package-essentials/][`use-package` essentials]]
use-package is very smart.
`:hook` is not only used for lazy loading, but also activates the mode in question.
`:mode` lazy loads when a pattern is matched and activates the mode.

#+begin_example elisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  ;; same as lazy load package on prog-mode and create this hook

  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_example

- `:defer t` will defer loading the package until something triggers it's loading.
Well maintained packages have their functions and keybinds autoloaded.
So they will activate themselves.
- `:defer` is not needed if you have :hook, :bind or :mode.



Hide a minor mode from the modeline.
https://github.com/myrjola/diminish.el
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; use-package syntax
;; :init - run code before import
;; :config - run code after import
;; :diminish mode - hide mode from modeline
(use-package diminish)
#+end_src

[[https://github.com/quelpa/quelpa][Quelpa]] allows for installation of packages from a wide range of sources.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq quelpa-checkout-melpa-p nil) ; disable melpa functionality, only use for recipe-based install
(use-package quelpa)
(use-package quelpa-use-package
  :after quelpa)
#+end_src
Now quelpa can be used via [[https://github.com/quelpa/quelpa-use-package][`use-package`]].
[[https://github.com/melpa/melpa/#recipe-format][See recipe format.]]

** Evil
:tangle "init.el"
#+begin_src emacs-lisp :results silent
(use-package evil
  :init
  (setq evil-want-keybinding nil)
  :config
  (evil-mode t))
                                        ; Vim Bindings Everywhere else
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init)
  (diminish 'evil-collection-unimpaired-mode))

(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode)
  :diminish)

;; evil states in the mode-line
(defface evil-normal-state-tag-face
  '((t (
        :background "#005fd7" ; blue
        :foreground "#1c1c1c"
        :box (:line-width 2 :color "#005fd7"))))
  "Face for the evil NORMAL state tag.")
(defface evil-insert-state-tag-face
  '((t (
        :background "#00ff5f" ; green
        :foreground "#1c1c1c"
        :box (:line-width 2 :color "#00ff5f"))))
  "Face for the evil INSERT state tag.")
(defface evil-visual-state-tag-face
  '((t (
        :background "#ff5f00" ; orange
        :foreground "#1c1c1c"
        :box (:line-width 2 :color "#ff5f00"))))
  "Face for the evil VISUAL state tag.")
(defface evil-replace-state-tag-face
  '((t (
        :background "#d70000" ; orange
        :foreground "#1c1c1c"
        :box (:line-width 2 :color "#d70000"))))
  "Face for the evil REPLACE state tag.")

(use-package evil
  :config
  (setq evil-normal-state-tag (propertize "\u200b NORMAL \u200b" 'face 'evil-normal-state-tag-face))
  (setq evil-insert-state-tag (propertize "\u200b INSERT \u200b" 'face 'evil-insert-state-tag-face))
  (setq evil-visual-state-tag (propertize "\u200b VISUAL \u200b" 'face 'evil-visual-state-tag-face))
  (setq evil-replace-state-tag (propertize "\u200b REPLACE \u200b" 'face 'evil-replace-state-tag-face))
  (setq evil-motion-state-tag (propertize "\u200b MOTION \u200b" 'face 'evil-normal-state-tag-face))
  (setq evil-operator-state-tag (propertize "\u200b OPRTOR \u200b" 'face 'evil-normal-state-tag-face))
  (setq evil-emacs-state-tag "EMACS")
  )

;; TODO: fix and replace evil-commentary
;; (use-package smart-comment
;;   :config
;;   (evil-global-set-key "normal" (kbd "gc") 'smart-comment))

;; fix RET being overwritten in org-mode (and maybe others)
;; (with-eval-after-load 'evil
;;                       (evil-define-key 'normal org-mode-map (kbd "RET") nil)
;;                       (dolist (map (list evil-normal-state-map
;;                                          evil-motion-state-map))
;;                         (define-key map (kbd "RET") nil)))
#+end_src

*** Prevent ZZ from terminating the server
My emacs is running as a server.
Closing the last window on the graphical *server session* would terminate the
server.

Evil's ZZ will close the last window without qualms.
Below I remap it to write the file, but only close the window if that will not
result in terminating the server.

Close the window under these conditions:
1. Frame is a terminal client.
   I found no good way to differentiate between graphical clients, since client don't have state of their own.
   With the terminal I can be sure it's a /client/.
2. Multiple tabs are open.
3. Frame is split.

#+begin_src emacs-lisp :results silent
(use-package general
  :defer 1
  :config
  (general-define-key
   :states 'normal
   "Z Z" (lambda ()
           (interactive)
           (if (or (not (display-graphic-p))
                   (> (length (tab-bar-tabs)) 1)
                   (not (one-window-p)))
               (condition-case nil ; catch "Buffer is not associated with a file" and also close windows like scratch
                   (evil-save-modified-and-close nil)
                 (error (delete-window)))
             (progn
               (evil-save nil t)
               (message "Prevented session from closing the server.")))))
  )
#+end_src

** Mode line
https://github.com/TheBB/spaceline
https://github.com/domtronn/all-the-icons.el/wiki/Spaceline

Faces to be used:
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defface grey-on-grey '((t ( :foreground "dim grey" :background "#1c1c1c")))
  "Grey on default background")
(defface white-on-grey '((t ( :foreground "floral white" :background "#1c1c1c")))
  "White on default background")
#+end_src

Define custom flycheck status segment.
Basically: Only show me a status when something is wrong.
Otherwise, don't take up space in my modeline.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package spaceline)
(use-package spaceline-config
  :ensure nil
  :after spaceline
  :config
  (spaceline-define-segment flycheck-status "Custom flycheck status"
                            (let* ((text
                                    (pcase flycheck-last-status-change
                                      (`finished (if flycheck-current-errors
                                                     (let ((count (let-alist (flycheck-count-errors flycheck-current-errors)
                                                                    (+ (or .warning 0) (or .error 0)))))
                                                       (format "✖ %s Issue%s" count (if (eq 1 count) "" "s")))
                                                   "         ")) ;; No issues
                                      (`running     "         ")
                                      (`no-checker  "⚠")
                                      (`not-checked "         ") ;; Disabled
                                      (`errored     "⚠ Error")
                                      (`interrupted "⛔ Interrupted")
                                      (`suspicious  "")))
                                   (face-formatting (cond
                                                     ((string-match "⚠" text) `(:height 0.9 :inherit))
                                                     ((string-match "✖ [0-9]" text) `(:height 0.9 :background "#1c1c1c" :foreground "#d70000"))
                                                     ((string-match "✖ Disabled" text) `(:height 0.9 :inherit))
                                                     (t '(:height 0.9 :inherit)))))
                              (propertize (format "%s" text)
                                          'face face-formatting
                                          'help-echo "Show Flycheck Errors"
                                          'display '(raise 0.1)
                                          'mouse-face '(:box 1)
                                          'local-map (make-mode-line-mouse-map 'mouse-1 (lambda () (interactive) (flycheck-list-errors)))))
                            :when active)
  )

(use-package spaceline-config
  :ensure nil
  :after spaceline
  :config
  (defface hudred '((t ( :foreground "#d70000" :background "#d70000"))) "Red for the hud")
  (spaceline-define-segment red-hud
    "A HUD that shows which part of the buffer is currently visible."
    (powerline-hud 'hudred 'grey-on-grey)
    :tight t)

  (spaceline-compile "jneidel"
    ;; left side
    '(
      ((;; evil-state
        buffer-modified
        buffer-id) ; TODO: include file path in buffer-id
       :face 'white-on-grey
       :separator " "
       :tight-left t
       :priority 100)
      (major-mode
       :face 'grey-on-grey
       :priority 79)
      (flycheck-status
       :face 'grey-on-grey
       :priority 89)
      (process
       :face 'grey-on-grey
       :when active)
      ;;(version-control
      ;; :when active
      ;; :priority 78)
      (org-clock
       :face 'grey-on-grey
       :when active)
      )
    ;; right side
    '(
      (selection-info
       :face 'grey-on-grey
       :priority 95)
      (minor-modes
       :face 'grey-on-grey
       :priority 9
       :separator " ")
      (remote-host
       :face 'grey-on-grey
       :priority 98)
      (global
       :face 'grey-on-grey
       :when active)
      (red-hud
       :face 'grey-on-grey
       :priority 99)
      )
    )
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-jneidel)))) ; activate
  )
#+end_src

When I trigger a system-wide keybinding (i3, rofi, brightness, volum, etc.) the
modeline would flash (black to white and back), because the emacs session lost
focus.
To prevent this flashing I remove the box around the modeline faces and
explicitly overwrite their backgrounds.
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; (set-face-attribute 'mode-line nil
;;                     :box nil)
;; (set-face-attribute 'mode-line-inactive nil
;;                     :box nil)

(use-package spaceline-config
  :ensure nil
  :after spaceline
  :config
  (set-face-attribute 'mode-line nil
                      :background "#1c1c1c"
                      :box nil)
  (set-face-attribute 'mode-line-inactive nil
                      :background "#1c1c1c"
                      :box nil)
  (set-face-attribute 'powerline-active0 nil
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line)
  (set-face-attribute 'powerline-active1 nil ; major mode
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line)
  (set-face-attribute 'powerline-active2 nil ; file-format
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line)
  (set-face-attribute 'powerline-inactive0 nil
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line-inactive)
  (set-face-attribute 'powerline-inactive1 nil
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line-inactive)
  (set-face-attribute 'powerline-inactive2 nil
                      :background "#1c1c1c"
                      :box nil
                      :inherit 'mode-line-inactive)
  (set-face-attribute 'fringe nil
                      :background "#1c1c1c")
  (set-face-attribute 'default nil
                      :background "#1c1c1c")
  )
#+end_src

** Styling
#+begin_src emacs-lisp :tangle "init.el" :results silent
(set-frame-font "ComicCodeLigatures Nerd Font 13" nil t)
(when (eq system-type 'darwin)
  (set-frame-font "ComicCodeLigatures Nerd Font 16" nil t))

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(set-face-attribute 'underline nil
                    :inherit 'default
                    :underline t)

(setq blink-cursor-blinks 10
      blink-cursor-mode nil)
#+end_src

** Bindings
https://github.com/noctuid/general.el
#+begin_src emacs-lisp :results silent
(use-package general) ;; https://github.com/noctuid/general.el#evil-examples

;; <leader> and <localleader>
  ;;;; use as (evil-define-key 'normal 'global (kbd "<leader>fs") 'save-buffer)
(evil-set-leader nil (kbd "C-SPC"))
(evil-set-leader 'normal (kbd "SPC"))
;; local leader
(evil-set-leader 'normal "," t)

(defun jneidel/jump-to-placeholder ()
  "Jump to the next <++>, replace it and go into insert mode."
  (interactive)
  (let ((placeholder-found
         (search-forward "<++>" nil t)))
    (if placeholder-found
        (progn
          (goto-char (match-beginning 0))
          (delete-char 4)
          (evil-insert-state)
          )
      (message "No <++> found"))))

(general-define-key
 :states 'normal
 ", ," 'jneidel/jump-to-placeholder)
#+end_src

https://github.com/abo-abo/hydra
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package hydra
  :bind (("C-+ +" . text-size-hydra/text-scale-increase)
         ("C-+ -" . text-size-hydra/text-scale-decrease))
  :config
  (defhydra text-size-hydra (global-map "C-+") "Adjust text size"
    ("+" text-scale-increase "bigger")
    ("-" text-scale-decrease "smaller")
    ("=" (text-scale-set 0) "set default")
    ("d" (text-scale-set 0) "set default")
    ("f" (text-scale-set 6) "set far"))
  )

(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "M-u") 'undo)
(global-set-key (kbd "M-RET") 'eshell)
#+end_src

Move between windows.
[[https://www.emacswiki.org/emacs/WindMove][WindMove]] (built-in).
#+begin_src emacs-lisp :results silent

(general-define-key
 :states 'normal
 "H" 'windmove-left
 "L" 'windmove-right
 "K" 'windmove-up
 "J" 'windmove-down
)

(general-define-key
 ;; reassign common evil binds
 "C-S-j" 'evil-join
 "M-j" 'evil-join
 "M-k" 'default-indent-new-line ; reassing from M-j
 "C-v" 'evil-paste-after
 )

(general-define-key
 :states 'insert
 "C-v" 'evil-paste-after)
 #+end_src

Resize windows
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package move-border
  :quelpa (move-border :fetcher github :repo "ramnes/move-border")
  :bind (
   ("M-H" . 'move-border-left)
   ("M-L" . 'move-border-right)
   ("M-K" . 'move-border-up)
   ("M-J" . 'move-border-down)
 ))
#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; (define-key key-translation-map (kbd "ESC") (kbd "C-g"))

(use-package general
  :config
  (general-define-key
   "C-x h" 'previous-buffer
   "C-x l" 'next-buffer
   "H-u" 'undo ; defaults are too long: C-S-7, C-_, C-x u; I need something without simple so I can spam it
   "H-j" 'other-window
   "H-k" 'other-window
#+end_src

Acting by S-Expressions/balanced expressions.
Those are pairs of ="= or ='= around strings and =()=, =[]=, ={}=.
Emacs bindings are familiar, only using the =C-M= modifier (e.g. =C-M-f= =
forward-sexp.)
#+begin_src emacs-lisp :tangle "init.el" :results silent
   "C-M-d" 'kill-sexp ; to mirror M-d
   "C-M-j" 'down-list ; jump into nearest sexp after point
   "C-M-k" 'backward-up-list ; jump out of and to the beginning of sexp
))
#+end_src

Enabled non-prefixed repeats for some commands, like undo.
For example =C-x u u u= instead of =C-x u C-x u C-x u=.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(repeat-mode 1)
#+end_src

** Tabs
#+begin_src emacs-lisp :tangle "init.el" :results silent
                                        ; https://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html

                                        ; upgrade to: https://github.com/ema2159/centaur-tabs

(setq tab-bar-show 1
      tab-bar-auto-width nil
      tab-bar-auto-width-max '(220 30)
      tab-bar-close-button-show nil
      tab-bar-format '(tab-bar-format-history tab-bar-format-tabs tab-bar-separator))
(tab-bar-mode t)

(set-face-attribute 'tab-bar nil
                    :background "#1c1c1c"
                    :slant 'italic
                    :height 0.85)
(set-face-attribute 'tab-bar-tab nil
                    :inherit 'tab-bar
                    :foreground "#d70000"
                    :box nil)
(set-face-attribute 'tab-bar-tab-inactive nil
                    :inherit 'tab-bar-tab
                    :foreground "dim grey"
                    :background 'unspecified)

(general-define-key
 "ħ" 'tab-previous ;; AltGr + h, default C-S-tab
 "ł" 'tab-next)    ;; AltGr + l, default C-tab

                                        ; bindings
;; C-x t r: rename tab
#+end_src

** Org-mode
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package org
  :ensure nil
  :config
  (set-face-attribute 'org-block nil
                      :background "grey6")
  (set-face-attribute 'org-block-begin-line nil
                      :background "grey8" ; a shade between the blocks darker grey and the backgrounds brighter gray
                      :foreground "#0030a0"
                      :overline "red4")
  (unless (eq system-type 'darwin)
    (set-face-attribute 'org-block-end-line nil
                        :overline nil
                        :underline '(:color "red4" :position t :style dashes)))
  (set-face-attribute 'org-level-1 nil
                      :height 200)
  (set-face-attribute 'org-level-2 nil
                      :height 180)
  (set-face-attribute 'org-level-3 nil
                      :height 160)
  (set-face-attribute 'org-level-4 nil
                      :height 140)
  )
#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; break text at 80 chars
(set-fill-column 80) ;; change dynamicly: C-x f
(add-hook 'org-mode-hook #'(lambda ()
                             (auto-fill-mode 1)
                             (setq-local tab-width 8) ; org-mode needs this or it prevents tangling files
                             ))
(diminish 'auto-fill-function)

(setq org-startup-with-inline-images t)

(defun jneidel/insert-org-list-item ()
  "Insert a new item at the same level as the current list item."
  (interactive)
  (if (org-table-check-inside-data-field t)
      (next-line)
    (let* ((context (org-element-lineage (org-element-context) '(item) t))
           (bullet (when context (org-element-property :bullet context)))
           (indent (if bullet
                       (make-string (org-get-indentation) ?\s)
                     "")))
      (if bullet
          (progn
            (end-of-line)
            (insert "\n" indent bullet "")
            (org-ctrl-c-ctrl-c) ;; fix ol
            ;; (evil-insert-state)
            )
        (progn
          (end-of-line)
          (insert "\n- " )
          ;; (evil-insert-state)
          )))))

(defun jneidel/insert-org-list-item-or-copy-down-table ()
  "Insert a new item at the same level as the current list item.
      If in a table, copy down values."
  (interactive)
  (if (org-table-check-inside-data-field t)
      (org-table-copy-down 1) ;; default S-RET functionality
    (jneidel/insert-org-list-item)))

;; https://orgmode.org/manual/Checkboxes.html
(defun jneidel/org-set-checkbox-in-progress ()
  (interactive)
  (org-toggle-checkbox '(16)))

(defun jneidel/insert-latest-chart-screenshot ()
  "Insert the latest chart screenshot."
  (interactive)
  (let ((latest_chart (string-trim (shell-command-to-string "screenshot-chart get_latest"))))
    (if (not (string-empty-p latest_chart))
        (insert (format "[[file:%s]]\n" latest_chart))
      (message "Take a chart screenshot first."))))

;; recalc formulas
;; TODO: enhance by checking if output is "Not a table" and running the command
;; of C-c C-c (recalc if on TBLFM)

(use-package org
  :ensure nil
  :defer t
  :bind (:map org-mode-map
         ("C-c C-+" . org-table-iterate)
         ;; ("g i" . org-toggle-inline-images)
         ;; ("g l" . org-insert-link)
         ;; ("g a" . jneidel/insert-latest-chart-screenshot)
         ;; ("g t p" . jneidel/org-set-checkbox-in-progress)
         ;; ("g r" . org-table-recalculate)
         ;; ("TAB" . org-cycle)
         ;; ("<S-return>" . jneidel/insert-org-list-item-or-copy-down-table)
         ("M-j" . org-metadown)
         ("M-k" . org-metaup)
         ("M-h" . org-metaleft)
         ("M-l" . org-metaright)
         ;; (kbd "RET") #'jneidel/insert-org-list-item ;; RET in cal doesn't work anyway
         ("C-c a" . org-table-recalculate)
         ))

  ;; (evil-define-key "insert" org-mode-map
  ;;   (kbd "<S-return>") #'jneidel/insert-org-list-item-or-copy-down-table
  ;;   (kbd "C-c a") #'org-table-recalculate
  ;;   (kbd "<leader> d") #'org-ctrl-c-ctrl-c ;; toggle done/undone
  ;;   )
    ;;; evil-define-key does not need with-eval-after-load and can assign multiple at once

  ;; Outline headings
  (with-eval-after-load 'outline
    (set-face-attribute 'outline-1 nil
                        :inherit 'font-lock-function-name-face
                        :foreground "#EA3D54")
    (set-face-attribute 'outline-4 nil
                        :inherit 'font-lock-comment-face
                        :foreground "orange")
    (set-face-attribute 'outline-6 nil
                        :inherit 'font-lock-constant-face
                        :foreground "green"
                        :weight 'normal)
    (set-face-attribute 'outline-8 nil
                        :inherit 'font-lock-string-face
                        :foreground "purple")
    )
         #+end_src

Automates the use-case of inserting a link from the clipboard into an org
document.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun insert-url-as-org-link-fancy ()
  "Version of org-insert-link that uses the link from the clipboard if there is
one. Otherwise just call org-insert-link."
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD)))
        (url  "\\(http[s]?://\\|www\\.\\)"))
    (save-match-data
      (if (string-match url link)
          (let ((description (read-string "Description: ")))
            (insert (concat "[[" link "][" description "]]")))
        (call-interactively #'org-insert-link)
        ))))

(general-define-key
 :keymaps 'org-mode-map
 "C-c C-l" 'insert-url-as-org-link-fancy)
#+end_src

*** Code blocks
Execute the code within source blocks with <kdb>C-c C-c</kbd>.
Disable the default confirmation prompt for these executions:
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq org-confirm-babel-evaluate nil)
#+end_src

The langages which can be evaluated inline with `C-c C-c`.

#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq org-babel-load-languages '((emacs-lisp . t)
                                 (shell . t)
                                 (octave . t)
                                 (js . t)
                                 (python . t)
                                 (makefile . t)))
#+end_src
[[https://orgmode.org/worg/org-contrib/babel/languages/index.html][See the list of available languages for `org-babel-load-languages`.]]

Fix [[https://emacs.stackexchange.com/questions/64886/indentation-in-org-mode-source-block-with-return][this undesired behavior]] where under some condition in the src block on
pressing RET the entire block would be repeatedly indented.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq org-src-preserve-indentation t)
#+end_src

*** Org-capture
[[info:org#Capture templates][Info page about capture templates]]
https://orgmode.org/manual/Capture-templates.html
#+begin_src elisp :tangle "init.el" :results silent
(global-set-key (kbd "C-c c") 'org-capture)

(use-package org-capture
  :ensure nil
  :bind ("C-c c" . org-capture)
  :config
  (setq org-capture-templates '())

  ;; (add-hook 'org-capture-mode-hook #'evil-insert-state)

  (defvar jneidel-note-capture-location nil
    "Temporary path for current org-capture note.")
  (defun jneidel-generate-note-capture-location ()
    "Generate a temp file path, store it and open it."
    (setq jneidel-note-capture-location
          (make-temp-file "org-capture-" nil ".org"))
    ;; template target (function …) expects file to be opened
    (find-file jneidel-note-capture-location)
    (goto-char (point-min)))
  (defun jneidel-note-capture ()
    "Extract the title and move the note to the inbox."
    (let* ((title (string-trim (shell-command-to-string
                                (format "grep -E '^#\\+(TITLE|title):.*' %s | cut -d: -f2-" jneidel-note-capture-location))))
           (inbox (substitute-in-file-name "$ORG_INBOX/"))
           (new-note-filename (expand-file-name (concat title ".org") inbox))
           (capture-buffer (find-buffer-visiting jneidel-note-capture-location)))
      (progn
        (kill-buffer capture-buffer)
        (rename-file jneidel-note-capture-location new-note-filename t)
        (message "Wrote note %s" new-note-filename))
      )
    ;; TODO support capture of 2+ notes at the same time
    ;; TODO check and handle if destination file already exists
    )
  (add-to-list 'org-capture-templates
               `("n" "Note" plain
                 (function jneidel-generate-note-capture-location)
                 ,(concat "#+title: %?\n"
                          "#+date: %t\n"
                          "\n%a\n%i")
                 :hook delete-other-windows
                 :after-finalize jneidel-note-capture
                 ))

  ;; tasks
  (add-to-list 'org-capture-templates
               '("m" "Message to send" entry
                 (file+headline (lambda () (substitute-in-file-name "$ORG_INBOX/messages to send.org")) "Messages to send")
                 "* TODO %?\n"
                 :prepend 1 :empty-lines-after 1))

  (add-to-list 'org-capture-templates
               '("t" "Task" entry
                 (file+headline "~/org/tasks.org" "Tasks")
                 "* TODO %?\n  %i\n  %a"))

  (add-to-list 'org-capture-templates
               '("h" "Health journal" item
                 (file+olp+datetree "~/org/2_areas/body/health-journal.org")
                 "%?\n"
                 :prepend 1))

  ;; sprint retrospective for work
  (setq retro-notes (substitute-in-file-name "$DAVA_ORG/2_areas/retro notes.org"))
  (add-to-list 'org-capture-templates
               '("g" "Retro Goodness" entry
                 (file+headline retro-notes "Goodness")
                 "* %?\n  %t"
                 :prepend 1 :empty-lines-after 1))
  (add-to-list 'org-capture-templates
               '("b" "Retro Goodness" entry
                 (file+headline retro-notes "Badness")
                 "* %?\n  %t"
                 :prepend 1 :empty-lines-after 1))
  )
#+end_src
- refactor with: https://miguelcrespo.co/posts/using-org-capture-to-create-new-org-files
- ideas from: https://howardism.org/Technical/Emacs/capturing-content.html
  & https://protesilaos.com/emacs/dotemacs#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d
- further info: https://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/

**** Keybinds
- `C-c c` org-capture
- `C-u C-c c` Visit the target location of a capture template.
- `C-u C-u C-c c` Visit the last stored capture item in its buffer.

*** Org-agenda
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun set-org-agenda-files ()
  "Set to directories which contain todos.
Expand project and area dirs to include todo files at the first level inside of a project/area."
  (interactive)
  (let* ((files-as-is (list (substitute-in-file-name "$ORG")
                            (substitute-in-file-name "$HOME/.emacs.d/dotemacs.org")
                            (substitute-in-file-name "$ORG_INBOX")))
         (subdirectories-one-level-deep-to-be-expanded (list (substitute-in-file-name "$ORG_PROJECTS")
                                                             (substitute-in-file-name "$ORG_AREAS"))))

    (setq org-agenda-files
          (append files-as-is
                  (mapcan
                   (lambda (root)
                     (let* ((r (file-name-as-directory (expand-file-name root)))
                            (children (directory-files r nil "^[^.]" t)))
                       (mapcar #'file-name-as-directory
                               (seq-filter #'file-directory-p
                                           (mapcar (lambda (name) (expand-file-name name r))
                                                   children)))))
                   subdirectories-one-level-deep-to-be-expanded)))))

(setq org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t% s") ; everything but todo are the defaults
                                 (todo . "%-2i %-40(org-agenda-directory): ")
                                 (tags . " %i %-12:c")
                                 (search . " %i %-12:c")))

(defun org-agenda-directory ()
  "Return the base directory name of the current org-agenda file."
  (let ((file (or (buffer-file-name (org-base-buffer (current-buffer)))
                  "")))
    (if (string-equal (file-name-nondirectory file) "index.org")
        (file-name-nondirectory (directory-file-name (file-name-directory file)))
      (file-name-sans-extension (file-name-nondirectory file)))))

(defun todos ()
  "Custom shortcut command to open org-todo-list"
  (interactive)
  (set-org-agenda-files)
  (org-todo-list))
#+end_src

Add [[https://github.com/egregius313/org-agenda-category-icons][icons]] to org-agenda:
#+begin_src emacs-lisp :tangle "init.el" :results silent
(when (eq system-type 'gnu/linux)
          (use-package org-agenda-category-icons
            :quelpa (org-agenda-category-icons :fetcher "github" :repo "egregius313/org-agenda-category-icons")
            :after all-the-icons
            :config
            (org-agenda-category-icons!
             :fileicon
             (emacs dotemacs)
             ;; :octicon
             ;; (comment "messages to send")
             )))
#+end_src

[[https://github.com/domtronn/all-the-icons.el][All the icons]].
Needs to run =M-x all-the-icons-install-fonts= once.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package all-the-icons
  :defer t
)

;; (use-package all-the-icons-dired
;;  :after all-the-icons
;;  :hook (dired-mode . all-the-icons-dired-mode)
;;  :config
;;  (set-face-attribute 'all-the-icons-dired-dir-face nil
;;                    :distant-foreground "#1c1c1c")
;;)
#+end_src

*** Org-modern
https://github.com/minad/org-modern

#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package org-modern
  :after org
  :config
  (with-eval-after-load 'org (global-org-modern-mode))
  (with-eval-after-load 'org (display-line-numbers-mode -1))

  ;; disable headings styles
  (setq org-modern-star nil
        org-modern-todo nil)

  ;; adjust list tasks styles
  (setq org-modern-checkbox
        '((88 . "") (45 . "") (32 . "×") (95 . "")))

  (set-face-attribute 'org-modern-date-active nil
                      :background "gray20"
                      :foreground "white"
                      :height 1.0
                      :inherit 'org-modern-label)
                                        ; :inverse-video - inverts back/fore colors
                                        ;    is needed so labels look consistent, when cursor is on the same line
  (set-face-attribute 'org-modern-done nil
                      :background "#1c1c1c"
                      :foreground "forest green"
                      :inverse-video t
                      :weight 'semi-bold
                      :inherit 'org-modern-label)
  (set-face-attribute 'org-modern-todo nil
                      :background "#1c1c1c"
                      :foreground "#d70000"
                      :inverse-video t
                      :weight 'semi-bold
                      :inherit 'org-modern-label)
  )
#+end_src

*** Snippets
[[https://orgmode.org/manual/Structure-Templates.html][structure template]] (has list of keys)

Not included by default anymore.
#+begin_quote
The new mechanism is called [[https://orgmode.org/manual/Structure-Templates.html][structure template]]. The command
`org-insert-structure-template` bound to `C-c C-,` gives you a list
of `#+begin_`-`#+end_` pairs that narrows down while you type and you can use
completion.
#+end_quote
https://emacs.stackexchange.com/a/46992

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; for <q TAB and more completions
(with-eval-after-load 'org
  (add-to-list 'org-modules 'org-tempo)
  )
#+end_src

Evaluate this for a list of all available keys.
#+begin_src elisp
(org-tempo--keys)
#+end_src

I use:
- <s: empty src
- <q: quote
- <e: example

(use-package yasnippet-snippets
:ensure t)
(use-package yasnippet
:ensure t
:config (yas-global-mode 1))

#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun hide-zero-cell(cell)
  (if (= (string-to-number cell) 0)
      ""
    cell))
(defun hide-minus-cell(cell)
  (if (< (string-to-number cell) 0)
      ""
    cell))
#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; https://github.com/QiangF/org-extra-emphasis/raw/refs/heads/main/org-extra-emphasis.el
;; (use-package ox-odt ; wrong version, because package is locked to specific version
;;   :ensure nil
;;   :after org)
;; (use-package org-extra-emphasis
;;   :after ox-odt
;;   :quelpa (org-extra-emphasis :fetcher github :repo "qiangf/org-extra-emphasis"))

#+end_src

** Info
#+begin_src elisp :tangle "init.el" :results silent
(set-face-attribute 'Info-quoted nil
                    :background "gold2"
                    :foreground "black"
                    :inherit nil)
#+end_src
** Flycheck

#+begin_src emacs-lisp :tangle "init.el" :results silent
  ;;; syntax checking

(use-package flycheck
  :diminish)
(add-hook 'after-init-hook #'global-flycheck-mode)

;; list of backends by language
;; https://www.flycheck.org/en/latest/languages.html#flycheck-languages

;; disable annoying reminders to have certain comments in your elisp files
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))

  ;;; C-c ! v - debug menu for major mode
#+end_src

* Completion

Emacs differentiates between two main types of completion.
1. Completing-read occurs in the minibuffer (M-x, find-file, and all sorts prompts).
2. Completion-at-point (and completion-in-region) are used to complete text in
   the buffer itself (pressing tab to complete a word, function, etc.)


Now package headlines like these don't seem so mysterious anymore:
- "🔍 consult.el - Consulting completing-read"
- "🏝️ corfu.el - COmpletion in Region FUnction"

** Completing-read (minibuffer)
#+begin_src emacs-lisp :results silent
(fido-mode t)
#+end_src

** Completion-at-point/in buffer (corfu)
[[https://github.com/minad/corfu][Corfu]] provides a pop-up UIs for completing words in the buffer.
As a UI it does not provide any completions of it's own.
It gets those from emacs-standard completion-at-point-functions (CAPFs), which
many modes, such as elisp-mode, eglot and lsp-mode, come with.

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; TAB key: fix indentation if needed, otherwise perform completion
(setq tab-always-indent 'complete)

(use-package corfu
  :if (display-graphic-p)
  :hook (after-init . global-corfu-mode)
  ;; :bind
  ;; (:map corfu-map
  ;;       ("<tab>" . corfu-next)
  ;;       ("<backtab>" . corfu-previous)
  ;;       )
  :custom
  (corfu-cycle t) ; cycle around to first entry after reaching the last
  (corfu-preview-current nil) ; don't expand text at point until I press return
  (corfu-min-width 20)
  (corfu-quit-at-boundary nil) ; contine matching completions with orderless after literal ones have been exhausted
  (corfu-on-exact-match 'insert) ; complete if there is only a single candidate
  :config
  (setq corfu-popupinfo-delay '(1.25 . 0.5))
  (corfu-popupinfo-mode 1) ; shows documentation next to completions

  ;; sort by input history
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history))
  )

(defun complete-first-then-indent ()
  "Try completion at point, if nothing completes then indent."
  (interactive)
  (unless (completion-at-point)
    (indent-for-tab-command)))
    #+end_src

[[https://github.com/minad/cape][Cape]] allows us to enable elisp completion inside of org source blocks.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package cape
  :init
  (add-hook 'completion-at-point-functions #'cape-elisp-block)
  )
#+end_src

[[https://github.com/jdtsmith/kind-icon][Kind-icon]] adds icons to corfu.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package kind-icon
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

;; fix overly large icons (https://github.com/jdtsmith/kind-icon/issues/22)
(setq kind-icon-default-style
      '(:padding -1 :stroke 0 :margin 0 :radius 0 :height 0.4 :scale 1))
#+end_src

;; Emacs 30 and newer: Disable Ispell completion function.
;; Try `cape-dict' as an alternative.
(setq text-mode-ispell-word-completion nil)

** Minibuffer
(`M-x` and friends.)

*** Vertico
[[https://github.com/minad/vertico][Vertico]] present minibuffer candidates in a vertical layout, one at a time.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package vertico
  :demand t
  :bind (:map minibuffer-local-map
              ("<tab>" . vertico-next)
              ("<backtab>" . vertico-previous))
  :config
  (vertico-mode t))
#+end_src

Verticos highlight font was clashing with the completion part:
#+begin_src emacs-lisp :tangle "init.el" :results silent
(set-face-attribute 'vertico-current nil
                    :background "#ffd700")
(set-face-attribute 'completions-common-part nil
                    :weight 'bold
                    :background "#d70000"
                    :foreground "#ffd700")
(set-face-attribute 'minibuffer-prompt nil
                    :foreground "#ffd700")

(use-package consult
  :defer t
  :config
  (set-face-attribute 'consult-preview-match nil
                      :background "#d70000"
                      :foreground "#ffd700")
  (set-face-attribute 'consult-highlight-match nil
                      :background "#d70000"
                      :foreground "#ffd700")
  )
#+end_src

**** Problems
- M-x, ^n to select an entry that is not the first one, return -> first entry
  was used
  by pressing tab, return the correct one is used though

*** Marginalia
[[https://github.com/minad/marginalia][Marginalia]] add descriptions or other relevant information to minibuffer menus.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package marginalia
  :config
  (marginalia-mode t))
#+end_src


#+begin_src emacs-lisp :tangle "init.el" :results silent
(set-face-attribute 'marginalia-documentation nil
                    :inherit nil
                    :slant 'italic
                    :foreground "grey35")
#+end_src

*** Consult & affe
[[https://github.com/minad/consult][Consult]] provides a suite of tools to interact with emacs in an enhanced way.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package consult
  :bind (("C-x 4 b" . consult-buffer-other-window)
         ("C-x t b" . consult-buffer-other-tab)
         ("H-o" . consult-outline)
         ("H-g" . consult-ripgrep)
         ("M-y" . consult-yank-pop)
         ([remap Info-search] . consult-info)
         ([remap list-buffers] . ibuffer)
         ))
#+end_src

=consult-buffer= is broken on mac. Only bind it on linux.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(when (eq system-type 'gnu/linux)
  (use-package consult
    :bind (("H-a" . consult-buffer)
           ("H-b" . consult-buffer)
           ([remap switch-to-buffer] . consult-buffer))))

(when (eq system-type 'darwin)
  (use-package consult
    :bind (("H-a" . switch-to-buffer)
           ("H-b" . switch-to-buffer))))
#+end_src

Matches for finding files are generated with ripgrep, which is much faster than
find.
To make it even faster I reduce the matches with ignore patterns.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defvar rg-ignore-flags
  "-g \"!*.mp3\" -g \"!*.png\" -g \"!*.jpg\" -g \"!*.JPG\" -g \"!*.jpeg\" \
  -g \"!*.pdf\" -g \"!*.mkv\" -g \"!*.mp4\" -g \"!*.avi\" -g \"!*.zip\" \
  -g \"!*.ods\" -g \"!*.xlsx\" -g \"!*.m3u\" -g \"!*.url\" -g \"!*.aac\" \
  -g \"!*.mpc\" -g \"!*.sql\" -g \"!*.ydb\" -g \"!dist/\" \
  -g \"!.git/\" -g \"!git/*\" -g \"!node_modules/\" -g \"!*cache/\" \
  -g \"!.cache\" -g \"!vendor/\" -g \"!teams-for-linux/\" -g \"!.local/\" \
  -g \"!.pki/\" -g \"!.local/share/*/\" -g \"!BraveSoftware/\" -g \"!chromium\" \
  -g \"!chrome/\" -g \"!firefox/\" -g \"!Signal\" -g \"!.ib-tws/\" -g \"!.java/\" \
  -g \"!.zcompcache\" -g \"!tmp/\" -g \"!ct/manga\" -g \"!ct/comics\" \
  -g \"!dotfiles/\" -g \"!coverage\" g \"!.mozilla/\" -g \"!.config/go/\" \
  -g \"!build/\" -g \"!.gradle/\" -g \"!elpa\" -g \"!.steam*\" -g \"!.factorio\" \
  -g \"!.docker\" -g \"!coc/\" -g \"!.node-gyp/\" -g \"!var/\" -g \"!npm/\" \
  -g \"!Library/\" -g \"!*.app\" -g \"!.DS_Store\" -g \"!quelpa\" -g \"!.stfolder\""
  "Exclusion flags for usage with ripgrep commands.")
(defvar rg-find-files-command
  (format "rg -L --ignore --hidden --files --color=never %s" rg-ignore-flags)
  "Command for finding files with ripgrep.")
(defvar rg-find-directories-command
  (format "rg-dir -L --ignore --hidden --color=never %s" rg-ignore-flags)
  "Command for finding directories with ripgrep.")
#+end_src

For find I prefer the interface of [[https://github.com/minad/affe][affe]].
It feels like fzf, but integrates with and looks like consult.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun affe-find-file (&optional dir) (interactive) ; default dir is cwd
       (setq affe-find-command rg-find-files-command)
       (affe-find dir))
(defun affe-find-directory (&optional dir) (interactive) ; default dir is cwd
       (setq affe-find-command rg-find-directories-command)
       (affe-find dir))
(defun affe-find-file-home () (interactive)
       (affe-find-file (substitute-in-file-name "$HOME")))
(defun affe-find-directory-home () (interactive)
       (affe-find-directory (substitute-in-file-name "$HOME")))
#+end_src

For finding files I prefer fast access to the global search (from home directory).
The local search (in current working directory or project) is available by
adding shift to the keybind.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package affe
  :bind (("H-f" . affe-find-file-home)
         ("H-F" . affe-find-file)
         ("H-s" . affe-find-directory-home)
         ("H-S" . affe-find-directory)
         )
  :init
  (setq affe-count 5000)
  )
#+end_src

*** Minibuffer Completion
Expand on this with
https://github.com/protesilaos/dotfiles/blob/master/emacs/.emacs.d/prot-emacs.org#54-the-prot-emacs-completionel-module

Problems:
- TODO lowercase query does not match until orderless kicks in

**** Orderless
[[https://github.com/oantolin/orderless][Orderless]] allows matching query terms out of order.
E.g. the query "in pack" will still match "package-install".
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package orderless)
(setq orderless-matching-styles '(orderless-prefixes orderless-flex))
(setq completion-ignore-case t)
#+end_src

The matching style of my choice is the one closest to how fzf works.
#+begin_quote
orderless-flex
the characters of the component should appear in that order in the candidate,
but not necessarily consecutively. This maps `abc` to `a.*b.*c`.
#+end_quote
Another example: "The input `lad` will thus match `list-faces-display` as well
as `pulsar-highlight-dwim`.

Enable orderless via the `completion-styles` variable, which checks for matches
in order.
So go from strictest to losest.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq completion-styles '(basic substring initials orderless)
      completion-category-overrides '((file (styles basic partial-completion))))
#+end_src

The [[https://github.com/oantolin/orderless?tab=readme-ov-file#overview][README]] has this to say about the fallback and overrides:
#+begin_quote
The basic completion style is specified as fallback in addition to orderless in
order to ensure that completion commands which rely on dynamic completion
tables, e.g., completion-table-dynamic or completion-table-in-turn, work
correctly.
Furthermore the basic completion style needs to be tried first (not as a
fallback) for TRAMP hostname completion to work. In order to achieve that, we
add an entry for the file completion category in the
completion-category-overrides variable. In addition, the partial-completion
style allows you to use wildcards for file completion and partial paths, e.g.,
/u/s/l for /usr/share/local.
#+end_quote

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; Hide commands in M-x which do not apply to the current mode.  Corfu
;; commands are hidden, since they are not used via M-x. This setting is
;; useful beyond Corfu.
(setq read-extended-command-predicate #'command-completion-default-include-p)
#+end_src

** Abbreviations
https://github.com/minad/cape can have them be transformed via completion
I want:
- :) -> 🙂

https://protesilaos.com/emacs/dotemacs#h:567bb00f-1d82-4746-93e5-e0f60721728a
https://github.com/minad/corfu section on dabbrev
** History
https://protesilaos.com/emacs/dotemacs#h:25765797-27a5-431e-8aa4-cc890a6a913a

#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode)
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 500) ; prot 100
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-to-list 'savehist-additional-variables 'kill-ring))
#+end_src

** Highlight Colors
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package rainbow-mode
  :defer 1
  :diminish
  :config
  (rainbow-mode 1))
#+end_src

** Fonts
Find out what font-face is used at point:
describe-text-properties

** Spellchecking
https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html

[[https://stackoverflow.com/a/9436234][Manual dictionary setup]]
https://emacs.stackexchange.com/questions/21378/spell-check-with-multiple-dictionaries
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq text-mode-ispell-word-completion nil)
(with-eval-after-load "ispell"
  (when (eq system-type 'gnu/linux) (progn
                                      (setq ispell-program-name "/bin/hunspell")
                                      (setq ispell-dictionary "en_US,de_DE")
                                      (ispell-set-spellchecker-params) ;; has to be called before ispell-hunspell-add-multi-dic will work
                                      (ispell-hunspell-add-multi-dic "en_US,de_DE")
                                      ))
  (when (eq system-type 'darwin) (progn
                                   (setq ispell-program-name "/usr/local/bin/hunspell")
                                   (setq ispell-dictionary "en_US")
                                   (ispell-set-spellchecker-params)
                                   (ispell-hunspell-add-multi-dic "en_US")
                                   ))
  )

(general-define-key
 :states 'normal
 "<localleader>s" 'flyspell-mode
 ;; for programming use: flyspell-prog-mode
 )
#+end_src

** Programming
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; global programming configuration

;; Turn on syntax highlighting whenever possible.
(global-font-lock-mode t)

;; highlight matching pairs of parentheses
(show-paren-mode t)
(setq show-paren-delay 0.0)

;; Treat CamelCaseSubWords as separate words in every programming mode
(use-package subword-mode
  :ensure nil
  :hook (prog-mode . subword-mode)
  :diminish subword-mode) ; doesnt work

;; https://github.com/jacktasia/dumb-jump
;; (use-package dumb-jump)
;; (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)

;; 2 spaces as default indentation
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
(setq sh-basic-offset 2)

;; overwrite e.g. indentation based on local editorconfig
(use-package editorconfig
  :hook (prog-mode . editorconfig-mode)
  :diminish editorconfig-mode)
#+end_src

*** Lisp
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
;;(add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

*** Line numbers
#+begin_src emacs-lisp :tangle "init.el" :results silent
(add-hook 'prog-mode-hook 'display-line-numbers-mode)

(setq display-line-numbers-type 'relative)

(set-face-attribute 'line-number nil
                    :background "#1c1c1c"
                    :foreground "dim gray")
(set-face-attribute 'line-number-current-line nil
                    :inherit 'line-number
                    :background "#ea3d54"
                    :foreground "#1c1c1c")
#+end_src

*** Eglot
[[https://github.com/joaotavora/eglot][Eglot]]
[[https://protesilaos.com/emacs/dotemacs#h:92258aa8-0d8c-4c12-91b4-5f44420435ce][Prots section]] (has nice description of typical capabilities)
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package eglot
  :ensure nil
  :functions (eglot-ensure)
  :commands (eglot)
  :hook (prog-mode . eglot-ensure) ; replace with actual programming modes
  ;; :config
  ;; (setq eglot-sync-connect nil)
  ;; (setq eglot-autoshutdown t)
  )
#+end_src
** Apps
*** Ledger
[[https://hledger.org/editors.html#emacs][hledger notes]]
[[https://github.com/narendraj9/hledger-mode][hledger-mode]]

TODO: lookat hledger-input for quick capture

TODO: write M-j move/down up functionality (kill entry (w/o poluting kill ring?)
move, call next entry, etc.)
[[https://chatgpt.com/c/68a6d758-fe88-832d-8416-beb6809803ff][failed attempt]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package hledger-mode
  :mode ("\\.journal\\'" . hledger-mode)
  :preface
  (defun hledger/next-entry ()
    "Move to next entry and pulse."
    (interactive)
    (hledger-next-or-new-entry)
    (hledger-pulse-momentary-current-entry))
  (defun hledger/prev-entry ()
    "Move to last entry and pulse."
    (interactive)
    (hledger-backward-entry)
    (hledger-pulse-momentary-current-entry))
  :bind (:map hledger-mode-map
              ("C-c j" . hledger-run-command)
              ("C-c e" . hledger-jentry)
              ("M-p" . hledger/prev-entry)
              ("M-n" . hledger/next-entry)
              ("M-+" . hledger-increment-entry-date)
              ("M--" . hledger-decrement-entry-date)
              ("TAB" . complete-first-then-indent)
              ("M-j" . hledger-move-entry-down)
              ("M-k" . hledger-move-entry-up)
              )
  :init
  (setq hledger-jfile (expand-file-name "~/code/geld/2024.journal"))
  :config
  ;; enable completion through corfu
  (defun hledger-completion-accounts ()
    (when-let ((bounds (and (boundp 'hledger-accounts-cache)
                            (bounds-of-thing-at-point 'symbol))))
      (list (car bounds) (point) hledger-accounts-cache)))
  (add-hook 'hledger-mode-hook
            (lambda ()
              (add-hook 'completion-at-point-functions 'hledger-completion-accounts)))

  )

(use-package flycheck-hledger
  :after hledger-mode)

(setq ledger-binary-path "hledger"
      ledger-highlight-xact-under-point nil
      ledger-use-iso-dates nil
      ledger-mode-should-check-version nil)

(with-eval-after-load 'hledger-mode
  (setq tab-width 2))
;; (when (memq window-system '(mac ns)) broken on mac, needed on linux?
;;   (exec-path-from-shell-copy-env "LEDGER_FILE")))

(add-hook 'ledger-mode-hook 'goto-address-prog-mode)

;; no rupee after transaction
;; src: https://github.com/narendraj9/hledger-mode/issues/39
(defun hledger-indent-account-line* ()
  "Called when the line to indent is an account listing line."
  (cond
   ((hledger-cur-line-matchesp (concat hledger-whitespace-account-regex "\\s-*" hledger-amount-value-regex))
    (insert "    "))
   ((hledger-expecting-rupeep) (insert "    "))
   (t (indent-line-to tab-width))))
(advice-add 'hledger-indent-account-line :override #'hledger-indent-account-line*)
#+end_src

** Automatically write
If I make I change I want to see it written to the file.
I don't want to think about it.
I can always undo if it wasn't what I needed.

This allows me, for example, to change some HTML, switch to my browser and see
the new change (because emacs wrote the file, which triggered browsersync, which
reloaded the page).

#+begin_src emacs-lisp :tangle "init.el" :results silent
;; discard buffer changes on file change
(global-auto-revert-mode t)

;; write buffer to file on loss of focus
(defun save-all ()
  (interactive)
  (save-some-buffers t))
(add-hook 'focus-out-hook 'save-all)

;; autosave when idle for 30sec or after 300 input events
(setq auto-save-timeout 30
      auto-save-interval 300)
#+end_src

** Backups
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][Backup files]] contain a copy of a file at a point in time.
They look like this: "dotemacs.el~".

By default emacs creates a copy only on the first save after a file has been
opened.
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; make emacs back up every time I save
(defun force-backup-of-buffer ()
  "Lie to Emacs, telling it the curent buffer has yet to be backed up."
  (setq buffer-backed-up nil))
(add-hook 'before-save-hook  'force-backup-of-buffer)

(setq version-control t) ;; keep multiple versions of a file
(setq delete-old-versions t) ;; silently delete execess backup versions, starting in the middle
(setq kept-new-versions 100)
(setq kept-old-versions 50)
(setq vc-make-backup-files t) ;; do back up files in git directories

;; keep backups out of my way
(setq backup-directory-alist '(("." . "~/.local/share/emacs/backups")))
#+end_src

Lockfiles prevent multiple users from editing the same file.
They look like this "#dotemacs.el#".
Since I can't configure the location to be somewhere else, I'd rather not have it.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq create-lockfiles nil)
#+end_src

** Misc fixes
I prefer elisp over the customize menu.
While not having a custom-file is not an options, this make it disposable and
keeps it out of the way.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(setq custom-file (make-temp-file "customize.el"))
#+end_src

Do not report warnings and errors from asynchronous native compilation.
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; make emacs backup every time I save
(setq confirm-kill-processes nil)

;; don't quit the emacs when I mess up a keybind
(general-define-key
 :states 'normal
 "C-x C-c" 'ignore)

;; Makes buffer management more elegant when working with "temporary" buffers
;; https://github.com/emacsmirror/fullframe
(use-package fullframe)

;; always follow symlinks
(setq vc-follow-symlinks t)

;; Allow 20MB of memory (instead of 0.76MB) before calling garbage collection.
;; This means GC runs less often, which speeds up some operations.
(setq gc-cons-threshold 20000000)

;; delete trailing whitespace on save
(add-hook 'before-save-hook 'delete-trailing-whitespace)

;; When saving a file that starts with `#!', make it executable.
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

;; single space after a period
(setq sentence-end-double-space nil)

;; offer to create parent directories on save
(add-hook 'before-save-hook
          (lambda ()
            (when buffer-file-name
              (let ((dir (file-name-directory buffer-file-name)))
                (when (and (not (file-exists-p dir))
                           (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                  (make-directory dir t))))))

;; (defun sensible-defaults/apply-changes-to-highlighted-region ()
;;   "Turn on transient-mark-mode."
(transient-mark-mode t)

;; If some text is selected, and you type some text, delete the
;; selected text and start inserting your typed text.
(delete-selection-mode t)

;; ensure that files end with newline
(setq require-final-newline t)

;; quiet startup
;; Don't present the usual startup message, and clear the scratch buffer.
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

;; Make dired file sizes human readable
(setq-default dired-listing-switches "-alh")

;; turn off audible beep and visible flashing
(setq visible-bell nil)
(setq ring-bell-function 'ignore)

;; default line length
(setq-default fill-column 80)

;; When middle-clicking the mouse to yank from the clipboard,
;; insert the text where point is, not where the mouse cursor is.
(setq mouse-yank-at-point t)

;; Yes-No prompts only ask for y/n
(setopt use-short-answers t)
(fset 'yes-or-no-p 'y-or-n-p)

(defun jneidel-Y-or-n-p (prompt)
  "Prompt user for (Y/n)."
  (if (string= "n"
               (downcase
                (read-from-minibuffer
                 (concat prompt "(Y/n) "))))
      nil
    t))
(defalias 'y-or-n-p 'jneidel-Y-or-n-p)

                                        ; use mail highlighting for neomutt mail buffers
(add-to-list 'auto-mode-alist '("/tmp/neomutt-.*" . message-mode))

;; includes some of https://github.com/hrs/sensible-defaults.el/tree/main


(setq mac-command-modifier 'meta
      mac-right-command-modifier 'hyper
      mac-right-option-modifier 'none) ; on macos don't touch the right option/alt key
#+end_src

; code inspiration from https://github.com/purcell/emacs.d

#+begin_src emacs-lisp :results silent
#+end_src

Have emacs running as a server and the connect to it as a client
https://www.polyomica.com/weekly-emacs-tip-27-emacs-as-a-server-daemon-and-emacsclient/
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package server
  :ensure nil
  :defer 1
  :config
  (unless (server-running-p) (server-start)))
#+end_src

** Git
** Window management

*** Switching windows
The default binding to switch windows is <kbd>C-x o</kbd>.
This cycles between windows, like <kbd>M-Tab</kbd> on Mac/Windows.
With two windows open it's fine.
At 3+ you have more than one keypress and a delay of "I press the binding, I
check if I am in the desired window" and repeat.
This scales terribly.

With a directional binding ("go to the right") I can omit the check "if I am in
the desired window" and it's always predictable.
The same thing applies to linux window managers.
I use i3 for the same reason.
My browser is always on <kbd>M+2</kbd>.
I don't have to cycle, I get what I except.
It needs less of my attention.

-> windmove

Bindings use the home row because I don't want to leave the home row for such a
common action.

*** Return to a previous layout
One constantly modifies the window layout.
New windows get opened and closed all the time.
You check your emails, but then want to return to the project you were working
on previously.

Winner mode allows you go go back and forth between these window layouts.

#+begin_src emacs-lisp :tangle "init.el" :results silent
(winner-mode)

(use-package general
  :defer t
  :config
  (general-define-key
   :states 'normal
   "C-c h" 'winner-undo ; backwards
   "C-c l" 'winner-redo ; forwards
   ))
#+end_src

*** Vterm, terminal
https://www.masteringemacs.org/article/running-shells-in-emacs-overview
https://github.com/akermu/emacs-libvterm
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package vterm
  :bind (("M-t"))
  :commands (vterm neomutt-mail ncmpcpp))
;; evil mode intercepts ESC -> disable evil
;; vterm mode intercepts Meta and Shift -> provide quick way to get out
;; (with-eval-after-load 'evil
;; (evil-set-initial-state 'vterm-mode 'emacs))

                                        ; enter
(general-define-key "M-t" 'vterm)
                                        ; exit
(general-define-key
 :keymaps 'vterm-mode-map
 "M-t" 'bury-buffer
 "M-F" (lambda () (interactive) (bury-buffer) (jneidel-fzf-directory "~")))

                                        ; better commands for copy and paste
(general-define-key
 :keymaps 'vterm-mode-map
 "C-v" 'yank)
#+end_src
`rename-buffer` to give give existing vterm a new name. "M-t" to spawn a new one.

**** TODO TUI apps via vterm (neomutt, ncmpcpp)
As temporary solutions provide access to mail client and music player via vterm
buffers.
Doing it like this is not great and I will migrate both of these over to their
emacs native apps with time.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun ncmpcpp ()
  "Open ncmpcpp in vterm."
  (interactive)
  (let ((buf (get-buffer-create "*ncmpcpp*")))
    (with-current-buffer buf
      (unless (derived-mode-p 'vterm-mode)
        (progn
          (vterm-mode)
          (vterm-send-string "ncmpcpps")
          (vterm-send-return))
        ))
    (pop-to-buffer buf))
  (delete-other-windows)
  )

(defun neomutt-mail ()
  "Open neomutt in vterm."
  (interactive)
  (let ((buf (get-buffer-create "*mail-neomutt*")))
    (with-current-buffer buf
      (unless (derived-mode-p 'vterm-mode)
        (progn
          (vterm-mode)
          (vterm-send-string "mail")
          (vterm-send-return))
        ))
    (pop-to-buffer buf))
  (delete-other-windows)
  )
#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun homepage()
  "Open homepage (empty scratch)."
  (interactive)
  (let ((buf (get-buffer-create "*homepage*")))
    (pop-to-buffer buf))
  (delete-other-windows)
  )
(global-set-key (kbd "H-h") 'homepage)
#+end_src

** Project
https://protesilaos.com/emacs/dotemacs#h:7dcbcadf-8af6-487d-b864-e4ce56d69530
https://www.gnu.org/software/emacs/manual/html_node/emacs/Projects.html

#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package project
  :ensure nil
  :bind
  (("C-x p p" . project-switch-project)
   ("C-x p ." . project-dired)
   ("C-x p C-g" . keyboard-quit)
   ("C-x p <return>" . project-dired)
   ("C-x p <delete>" . project-forget-project))
  )
#+end_src

** Major modes by file type
These major modes add highlighting and related tooling to specific files.

*** Programming
Everything programming related.

**** Markdown
[[https://github.com/jrblevin/markdown-mode][Markdown-mode]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package markdown-mode
  :mode ("\\.md\\'" . markdown-mode)
  :config
  (setq markdown-fontify-code-blocks-natively t))
#+end_src

**** Mermaid
[[https://github.com/abrochard/mermaid-mode][Mermaid mode]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package mermaid-mode
  :after markdown-mode)
#+end_src

**** PHP
[[https://github.com/emacs-php/php-mode][PHP mode]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package php-mode
  :mode ("\\.php\\'"))
#+end_src

**** YAML
[[https://github.com/yoshiki/yaml-mode][YAML mode]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package yaml-mode
  :mode ("\\.ya?ml\\'"))
#+end_src

*** Linux configuration files
**** sxhkd
[[https://github.com/protesilaos/sxhkdrc-mode][Major mode]] that provides highlighting for the [[https://github.com/baskerville/sxhkd][sxhkd]] config.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package sxhkdrc-mode
  :mode "sxhkdrc.*"
  :hook (sxhkdrc-mode . sxhkdrc-mode-auto-restart)
  :config
  (advice-add 'sxhkdrc-mode-restart-notify :override
              (lambda () (message "Restarted the sxhkd process")))
  )
#+end_src

*** Ebooks
[[https://depp.brause.cc/nov.el/][Nov.el]] for reading epubs.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package nov
  :mode ("\\.epub\\'" . nov-mode))
#+end_src
Alternatives:
- [[https://github.com/chenyanming/calibredb.el][Using calibre]]
- [[https://codeberg.org/divyaranjan/emacs-reader][Using mupdf]] (supports all ebook extensions)


https://github.com/chenyanming/nov-xwidget
https://redlib.privacyredirect.com/r/emacs/comments/v2fjec/a_new_epub_reader_in_emacs_novxwidgetel/
#+begin_src emacs-lisp :tangle "init.el" :results silent
(if (featurep 'xwidget-internal)
    (use-package nov-xwidget
      :quelpa (nov-xwidget :fetcher "github" :repo "chenyanming/nov-xwidget")
      :after nov
      ;;   :config
      ;;   (define-key nov-mode-map (kbd "o") 'nov-xwidget-view)
      ;;   (add-hook 'nov-mode-hook 'nov-xwidget-inject-all-files))
      ))
#+end_src

*** Remind
I use the [[https://dianne.skoll.ca/wiki/Remind][remind]] calendar.
There is no emacs packge for it, so this quick function displays a rendered
calendar in it's own buffer.
The date range is fixed at one month in the past and three into the future.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package ansi-color
  :ensure nil
  :commands (remind-calendar)
  :config
  (defun remind-calendar()
    "Display colored remind calendar."
    (interactive)
    (let ((buf (get-buffer-create "*remind-calendar*")))
      (with-current-buffer buf
        (read-only-mode -1)
        (call-process-shell-command
         "rem -b1 -cu3 -m -w141 -@2,0 $(date -d '-4 weeks' +%Y-%m-%d ) 2>/dev/null"
         ;; -4 weeks = 1 month into the past, -cu3 = 3 months into the future
         nil buf t)
        (ansi-color-apply-on-region (point-min) (point-max))
        (goto-char (point-min))
        (view-mode 1))
      (pop-to-buffer buf))
    (delete-other-windows)
    (search-forward "******") ;; find today
    (beginning-of-line)
    (recenter-top-bottom 1) ;; this week at the top of the screen
    ))
#+end_src

*** PKGBUILD
[[https://github.com/juergenhoetzel/pkgbuild-mode][mode]] for editing Arch Linux PKGBUILD files.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package pkgbuild-mode
  :quelpa (pkgbuild-mode :fetcher "github" :repo "juergenhoetzel/pkgbuild-mode")
  :config
  (setq pkgbuild-makepkg-command "yes | makepkg -mfcs")
  (setq pkgbuild-sums-command nil)
  )
#+end_src

** Help

Shows all a selection of relevant help options in case I don't remember
([[https://paste.pound-python.org/show/OJpNBWfjAjsyeklwNWqe/][Source]]).
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package hydra
  :bind ("C-h" . hydra-metahelp-menu/body)
  :config
  (setq my-default-hydra-delay 0.5)

  (defhydra hydra-metahelp-menu (:hint nil :exit t :idle my-default-hydra-delay :foreign-keys warn)
    "
  _k_ey briefly                    _m_ode                             _a_propos (all)
_C-k_ey                          _C-m_ode (customize)                 _i_nfo manual
                                 _p_ackage (by name)                search _C-i_nfo manuals
  _c_ommand                      _C-p_ackage (by group)               _d_ocumentation string (apropos)
_C-c_ommand (apropos)            _C-l_ibrary                        _C-m_an page
  _f_unction
_C-f_unction (info)                *M_e_ssages*                       About _C-e_macs
  _v_ariable                       _l_ossage (pressed keys)
  _s_ymbol
_C-s_ymbol (info)
  f_C-a_ce
  ke_y_map
  synta_x_
  by _C-v_alue (apropos)
"
    ("a"   apropos)
    ("C-a" describe-face)
    ("c"   describe-command)
    ("C-c" apropos-command)
    ("d"   apropos-documentation)
    ("e"   view-echo-area-messages)
    ("C-e" hydra-metahelp-emacs-menu/body)
    ("f"   describe-function)
    ("C-f" Info-goto-emacs-command-node)
    ("i"   info)
    ("C-i" consult-info)
    ("k"   describe-key-briefly)
    ("C-k" describe-key)
    ("l"   view-lossage)
    ("C-l" apropos-library)
    ("m"   describe-mode)
    ("C-m" customize-mode)
    ("C-m" consult-man)
    ("p"   describe-package)
    ("C-p" finder-by-keyword)
    ("s"   describe-symbol)
    ("C-s" info-lookup-symbol)
    ("v"   describe-variable)
    ("C-v" apropos-value)
    ("y"   describe-keymap)
    ("x"   describe-syntax)
    ;; not listed
    ("q"   nil nil)
    ("ESC" nil nil)
    ("b"   describe-bindings))

  (defhydra hydra-metahelp-emacs-menu (:hint nil :exit t :idle my-default-hydra-delay :foreign-keys warn)
    "
Emacs
----------------------------------------------------------------------------------------
_a_bout Emacs  _D_istribution  _h_ello file     _n_ews            _T_odo
_c_opying      _F_AQ           _i_nfo manual    known _p_roblems
_d_ebuging     _G_NU           order _m_anuals  _t_utorial
"
    ("a" about-emacs)
    ("c" describe-copying)
    ("d" view-emacs-debugging)
    ("D" describe-distribution)
    ("F" view-emacs-FAQ)
    ("G" describe-gnu-project)
    ("h" view-hello-file)
    ("i" info-manual)
    ("n" view-emacs-news)
    ("t" help-with-tutorial)
    ("m" view-order-manuals)
    ("p" view-emacs-problems)
    ("T" view-emacs-todo)
    ("q" nil nil))
  )

;; after pressing prefix key show available keys to press
(use-package which-key
  :if (eq system-type 'gnu/linux)
  :ensure nil
  :config
(which-key-mode 1)
(diminish 'which-key-mode)
(setq which-key-idle-delay 1.5))

(global-unset-key (kbd "<f1>")) ; unbind from global keymap
#+end_src
To show the options of a prefix one can append `C-h`.
For example `C-x 8 C-h` to list the various special characters contained behind
that prefix.

For other such prefix listing helpers see [[https://karthinks.com/software/persistent-prefix-keymaps-in-emacs/][here]]

https://www.emacswiki.org/emacs/InfoPlus
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package info+
  :quelpa (info+ :fetcher "wiki"))
#+end_src

** File manager (dirvish, dired)

[[https://www.youtube.com/watch?v=5dlydii7tAU][dired basics]]

dired-get-file-for-visit
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun dired-toggle-hidden-directories()
  "Toggle hidden directories"
  (interactive)
  (if (or (string-match-p "-A" dired-listing-switches) (string-match-p "-A" dired-actual-switches))
      (let ((switches (replace-regexp-in-string " -A" "" dired-listing-switches)))
        (setq dired-actual-switches switches)
        (setq dired-listing-switches switches)
        (message "Hide hidden directories")
        (revert-buffer))
    (let ((switches (concat dired-actual-switches " -A")))
      (setq dired-actual-switches switches)
      (setq dired-listing-switches switches)
      (message "Show hidden directories")
      (revert-buffer))
    ))

(defun dired-set-sort-switch(sort-value)
  "Update the --sort= switch in dired-actual-switches"
  (let* ((sort-option (concat " --sort=" sort-value))
         (switches
          (if (string-match " --sort=" dired-actual-switches)
              (replace-regexp-in-string " --sort=[^ ]+" sort-option dired-actual-switches)
            (concat dired-actual-switches sort-option))
          ))
    (setq dired-actual-switches switches)
    ))

;; TODO use $ORG_ var
;; TODO sortby time resource/*, areas/*, project/*
(defun dired-sort-on-cd()
  "Adjust sorting based on the directory"
  (let ((sortby (pcase default-directory ; cwd
                  ("~/org/" "name")
                  ("~/org/0_inbox/" "time")
                  ("~/org/1_project/" "version")
                  ((pred (string-match "^~/org")) "time")
                  (_ "name"))))
    (dired-set-sort-switch sortby)
    ))

(defun jneidel-dired-toggle-mark ()
  "Toggle the mark on the file at point in Dired/Dirvish."
  (interactive)
  (let ((inhibit-read-only t))
    (save-excursion
      (beginning-of-line)
      (if (looking-at dired-re-mark)
          (dired-unmark 1)
        (dired-mark 1)))
    (next-line)))

(defun touch (name)
  (interactive (list (read-string "File name: ")))
  (if (string-match-p "\\." name)
      (progn (shell-command (format "touch %s" name))
             (revert-buffer)
             (dired-goto-file (expand-file-name name default-directory)))
    (let ((file-name (format "%s.org" name)))
      (shell-command (format "generate-orgmode-metadata \"%s\" >\"%s\"" name file-name))
      (revert-buffer)
      (dired-goto-file (expand-file-name file-name default-directory))
      (dired-find-file)) ; used over find-file for consistency (work with dirvish preview)
    ))

(defun mkdir (name)
  (interactive (list (read-string "Directory: ")))
  (dired-create-directory (expand-file-name name default-directory))
  (dired-find-file))
#+end_src

Select a directory inside of the main categories of my note-taking system via the minibuffer.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun org-select-area ()
  "Prompt user to select an org area in $ORG_AREAS."
  (format "%s/%s" (substitute-in-file-name "$ORG_AREAS")
          (string-trim (shell-command-to-string
                        (format "select-area transform %s"
                                (completing-read "Pick area: "
                                                 (split-string (string-trim (shell-command-to-string "select-area")) "\n")))))))
(defun org-select-project ()
  "Prompt user to select an org project in $ORG_PROJECTS."
  (format "%s/%s" (substitute-in-file-name "$ORG_PROJECTS")
          (completing-read "Pick project: "
                           (split-string (string-trim (shell-command-to-string "select-project")) "\n"))))
(defun org-select-resource ()
  "Prompt user to select an org resource in $ORG_RESOURCES."
  (format "%s/%s" (substitute-in-file-name "$ORG_RESOURCES")
          (completing-read "Pick resource: "
                           (split-string (string-trim (shell-command-to-string "select-resource")) "\n"))))
(defun org-select-archive ()
  "Prompt user to select an org archive directory in $ORG_ARCHIVE."
  (format "%s/%s" (substitute-in-file-name "$ORG_ARCHIVE")
          (completing-read "Pick archive: "
                           (split-string (string-trim (shell-command-to-string "select-archive")) "\n"))))
#+end_src

Move file at point (or the marked files) to a fixed or selected location in my
note-taking system.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun move-to (destination)
  (dolist (to-be-moved (dired-get-marked-files)) ; if none marked, use the one at point
    (let ((target (expand-file-name (file-name-nondirectory to-be-moved) destination)))
      (dired-rename-file to-be-moved target nil)
      (message (format "Moved %s to %s" (file-name-nondirectory to-be-moved) destination))
      (revert-buffer))))

(defun move-to-inbox () (interactive) (move-to (substitute-in-file-name "$ORG_INBOX")))
(defun move-to-selected-resource () (interactive) (move-to (org-select-resource)))
(defun move-to-selected-area () (interactive) (move-to (org-select-area)))
(defun move-to-selected-project () (interactive) (move-to (org-select-project)))
(defun move-to-projects () (interactive) (move-to (substitute-in-file-name "$ORG_PROJECTS")))
(defun move-to-selected-archive () (interactive) (move-to (org-select-archive)))
(defun move-to-paperless () (interactive) (move-to (substitute-in-file-name "$ORG/.paperless_import")))
(defun move-to-blog-post-ideas () (interactive) (move-to (substitute-in-file-name "$ORG_AREAS/blog/posts/0_ideas")))
(defun move-to-designs () (interactive) (move-to (substitute-in-file-name "$ORG_DESIGN/1 ideas")))
(defun move-to-other-inbox () (interactive) (move-to (string-trim (shell-command-to-string "select-other-inbox"))))
(defun move-to-local-archive () (interactive) (let ((local-archive (expand-file-name ".archive" default-directory)))
                                                (make-directory local-archive t)
                                                (move-to local-archive)))
#+end_src

I use emoji to convey the status of the project at a glace:
- 🟢 is a project I am actively persuing
- 🟨 is a project that has fallen inactive, but will be continued
- 🪀 is an externally blocked project

The individual emoji representing the different colors of the traffic light were
chosen based on their unicode symbols.
Natural sort returns them in the correct order.
#+begin_src emacs-lisp :tangle "init.el" :results silent
(defun set-project-status (status)
  (let ((new-path (shell-command-to-string (format "project-status set %s '%s'" status (dired-get-file-for-visit)))))
    (revert-buffer)
    (dired-goto-file (string-trim new-path))
  ))
(defun prompt-for-status-line-update ()
  (let ((index-file (expand-file-name "index.org" (dired-get-file-for-visit))))
    (when (not (file-exists-p index-file))
      (shell-command (format "generate-orgmode-metadata \"index\" >\"%s\"" index-file)))

    (let ((updated-status
           (read-string "Update status line: "
                        (string-trim (shell-command-to-string
                                      (format "grep -Po '#\\+(status|STATUS): \\K.*' '%s' 2>/dev/null" index-file))))))

      (if (zerop (shell-command (format "grep '^#+status: ' '%s'" index-file)))
          (shell-command (format "sed -i 's/^#+status: .*/#+status: %s/' '%s'" updated-status index-file))
        (shell-command (format "echo '#+status: %s' >>'%s'" updated-status index-file)))
      )))

(defun set-project-status-active () (interactive) (prompt-for-status-line-update) (set-project-status "active"))
(defun set-project-status-inactive () (interactive) (set-project-status "inactive"))
(defun set-project-status-blocked () (interactive) (prompt-for-status-line-update) (set-project-status "blocked"))
(defun set-project-status-none () (interactive) (set-project-status "none"))
(defun set-project-status-important () (interactive) (set-project-status "important"))
#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package dired
  :ensure nil
  :custom
  (dired-listing-switches "--human-readable --color=always")
  (dired-deletion-confirmer 'always) ; TODO make this ask if removing a non-empty dir
  (dired-clean-confirm-killing-deleted-buffers nil)
  (dired-auto-revert-buffer #'dired-directory-changed-p)
  :bind (("C-x d" . dirvish)
         ("H-d" . dirvish)
         :map dired-mode-map
         ("H-d" . dirvish-quit)
         ("h" . dired-up-directory)
         ("l" . dired-find-file)
         ("j" . dired-next-line)
         ("k" . dired-previous-line)
         ("g" . dirvish-quick-access)
         ("." . dired-toggle-hidden-directories)
         ("SPC" . jneidel-dired-toggle-mark)
         ("I" . dired-toggle-marks) ; [I]nvert
         ("t" . touch)
         ("d" . mkdir)
         ("p" . dirvish-move) ; move marked into cwd
         ("y" . dirvish-yank) ; copy marked into cwd
         ("r m" . dired-do-delete)
         ("r s" . revert-buffer)
         ("/" . dirvish-narrow)
         ("i" . dirvish-history-go-forward)
         ("o" . dirvish-history-go-backward)
         ; dired-find-file-other-window ; quickly edit file in preview buffer
         ("m" . nil)
         ("m i" . move-to-inbox)
         ("m r" . move-to-selected-resource)
         ("m a" . move-to-selected-area)
         ("m p" . move-to-selected-project)
         ("m P" . move-to-projects)
         ("m A" . move-to-selected-archive)
         ("m s" . move-to-paperless)
         ("m b" . move-to-blog-post-ideas)
         ("m d" . move-to-designs)
         ("m I" . move-to-other-inbox)
         ("m l" . move-to-local-archive)
         ("ö a" . set-project-status-active)
         ("ö i" . set-project-status-inactive)
         ("ö b" . set-project-status-blocked)
         ("ö n" . set-project-status-none)
         ("ö !" . set-project-status-important)
         )
  :config
  (add-hook 'dired-before-readin-hook #'dired-sort-on-cd))
#+end_src

https://github.com/alexluigit/dirvish

https://github.com/alexluigit/dirvish/blob/main/docs/CUSTOMIZING.org
https://github.com/alexluigit/dirvish/blob/main/docs/EXTENSIONS.org
https://github.com/alexluigit/dirvish/issues/324
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package dirvish
  :commands
  (dirvish)
  :init
  (dirvish-override-dired-mode)
  (add-to-list 'load-path (concat user-emacs-directory "elpa/dirvish-2.3.0/extensions")) ; bug in 2.3.0
  :config
  (require 'dirvish-quick-access)
  (require 'dirvish-yank)
  (require 'dirvish-narrow)
  (require 'dirvish-history)
  ;; (require 'dirvish-vc)

  (require 'dirvish-peek)
  (dirvish-peek-mode 1) ; preview during find-file

  (require 'dirvish-icons)
  (setq dirvish-all-the-icons-height 0.8
        dirvish-all-the-icons-palette nil ; same font for icons as text
        dirvish-attributes '(all-the-icons))
  :custom
  (dirvish-quick-access-entries `(
                                  ("h" "~/"                          "Home")
                                  ("D" "~/Downloads/"                "Downloads")
                                  ("e" "~/.emacs.d/"                 "Emacs")
                                  ("c" "~/.emacs.d/dotemacs.org"     "Emacs config")
                                  ("C" "~/code"                      "Code")
                                  ("l" ".archive"                    "Local archive")
                                  ("o" ,(substitute-in-file-name "$ORG") "Org")
                                  ("i" ,(substitute-in-file-name "$ORG_INBOX") "Org Inbox")
                                  ("I" ,(string-trim (shell-command-to-string "select-other-inbox")) "Other Inbox")
                                  ("d" ,(substitute-in-file-name "$ORG_DESIGN") "Org Designs")
                                  ("p" ,(substitute-in-file-name "$ORG_PROJECTS") "Org Projcts")
                                  ("a" ,(substitute-in-file-name "$ORG_AREAS") "Org Areas")
                                  ("P" ,(substitute-in-file-name "$ORG_AREAS/blog/posts") "Blog posts")
                                  ("b" ,(substitute-in-file-name "$ORG_AREAS/blog") "Blog")
                                  ("r" ,(substitute-in-file-name "$ORG_RESOURCES") "Org Resources")
                                  ("n" ,(substitute-in-file-name "$ORG_RESOURCES/Neurostreams/Neurostreams") "Neurostreams")
                                  ("m" ,(substitute-in-file-name "$ORG_MEDIA") "Media")
                                  ("M" ,(substitute-in-file-name "$ORG_MEDIA/music") "Music")
                                  ("A" ,(substitute-in-file-name "$ORG_ARCHIVE") "Org Archive")
                                  ("s" ,(substitute-in-file-name "$ORG_INBOX/screenshots") "Screenshots") ; TODO show inbox if dir doesn't exist
                                  ))
  )

#+end_src

#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package dirvish
  :defer t
  :config
  (setq dirvish-default-layout '(0 0.6 0.4))
  ; (setq dirvish-default-layout nil)

(dirvish-define-preview eza (file)
  "Use `eza' to generate directory preview."
  :require ("eza") ; tell Dirvish to check if we have the executable
  (when (file-directory-p file) ; we only interest in directories here
    `(shell . ("eza" "-1h" "--group-directories-first" "--color=always" ,file))))

(push 'eza dirvish-preview-dispatchers)
#+end_src

In dirvish the line under point is marked up by the `dirvish-hl-line` face.
By default that is a fixed color as specified by the face.
Because of this you can't tell by the color if what you are on is a file or a directory.

I wanted the same effect as in lf, where the foreground color of the e.g.
directory turn into the background color when highlighted.
The built-in way to achive this would be with `inverse-video`:
#+begin_src elisp
  (set-face-attribute 'dirvish-hl-line nil
                       :inherit nil
                       :inverse-video t
                       :extend t
                       )
#+end_src
[[file:img/dirvish-hl-line-inverse-video.png]]

That already works, but I want the color to stretch across the whole width.
To achieve that we need to fetch the foreground color at point and apply it as a
background color for `dirvish-hl-line`.
This needs to be updated after every command run (which includes movement
comands).

TODO: advice quick-access to also run after changing into a dir (g p)
#+begin_src emacs-lisp :tangle "init.el" :results silent
(use-package dirvish
  :defer t
  :config
 (set-face-attribute 'dired-directory nil
                 :foreground "#005fd7"
                 :weight 'bold)
  (set-face-attribute 'dirvish-hl-line nil
                      :weight 'bold)
  )

(defun jn/dired--colors-at-filename ()
  "Return a plist (:fg COLOR :bg COLOR) of the face at point’s filename.
Falls back to the `default` face if needed."
  (save-excursion
    (when (ignore-errors (dired-move-to-filename nil) t)
      (let* ((fp (get-text-property (point) 'face))
             (face (cond ((facep fp) fp)
                         ((consp fp) (seq-find #'facep fp))
                         (t 'default)))
             (dfg (face-foreground 'default nil t))
             (dbg (face-background 'default nil t))
             (fg  (or (face-foreground face nil t) dfg))
             (bg  (or (face-background face nil t) dbg)))
        (list :fg fg :bg bg :dfg dfg :dbg dbg :face face)))))

(defun jn/dired-set-entry-fg-as-hl-bg ()
  "Achive a consistent inverse color effect by setting the foreground color from the entry at point as the background of `dirvish-hl-line'."
  (interactive)
  ;; (message "Called at %s in %s" (current-time-string) default-directory)
  (when (derived-mode-p 'dired-mode)
    (let* ((colors (jn/dired--colors-at-filename))
           (fg  (plist-get colors :fg))
           (bg  (plist-get colors :bg))
           (dfg (plist-get colors :dfg))
           (dbg (plist-get colors :dbg))
           ;; Does the entry at point have a custom bg color?
           (has-custom-bg (and bg (not (equal bg dbg)))))
      (if has-custom-bg
          ;; Case 1: extend the custom bg across the whole width
          (set-face-attribute 'dirvish-hl-line nil
                              :background bg
                              :foreground fg)
        ;; Case 2: invert bg and fg
        (set-face-attribute 'dirvish-hl-line nil
                            :background (or fg dfg)
                            :foreground (or bg dbg))))))

(defun jn/dired-inverse-hl-color-mode ()
  (interactive)
  ;; TODO does not work if a non-first entry is highlighted in a directy you are returning to
  (advice-add 'dirvish-post-command-h :after #'jn/dired-set-entry-fg-as-hl-bg)
  (add-hook 'dired-after-readin-hook ; trigger post-command after enter a directory
          (lambda ()
            (call-interactively #'next-line)
            )
          nil)
  (jn/dired-set-entry-fg-as-hl-bg))

(add-hook 'dired-mode-hook   #'jn/dired-inverse-hl-color-mode)
)
#+end_src

** TODO setup Latex

Broken in my setup.
[[https://karthinks.com/software/latex-input-for-impatient-scholars][configuring it]]
[[https://bwestbro.com/blogs/latex.html][simple setup]]
#+begin_src emacs-lisp :tangle "init.el" :results silent
;; (use-package auctex)
#+end_src

[[https://www.youtube.com/watch?v=u44X_th6_oY&pp=ygUUZW1hY3MgbGF0ZXggd29ya2Zsb3c%3D][latex preview everywhere]]
